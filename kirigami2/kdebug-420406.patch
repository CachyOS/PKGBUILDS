From 5dfa3e9e983bdd29cbb9f34d31b7bab50089430b Mon Sep 17 00:00:00 2001
From: Arjen Hiemstra <ahiemstra@heimr.nl>
Date: Thu, 23 Apr 2020 10:40:44 +0200
Subject: Various fixes to new Cards

Summary:
This contains various small fixes to the new Cards.

- Still show the border of AbstractCard on Cards with images.
- Round bottom corners of the banner when the card doesn't have any other contents.
- Don't use fwidth for smoothing, instead just use a fixed value, this increases the accuracy of lines rendered by cards.
- Fix batching test for ShadowedTexture, prevents cards being rendered with the wrong texture.

BUG: 420406

Test Plan: The new Kirigami Gallery displays more correct now, though there are some layout issues that are not regressions.

Reviewers: #kirigami, ndavis, mart

Reviewed By: #kirigami, ndavis, mart

Subscribers: ndavis, plasma-devel

Tags: #kirigami

Differential Revision: https://phabricator.kde.org/D29092
---
 src/controls/Card.qml                            | 19 +++++++----
 src/controls/private/BannerImage.qml             |  2 ++
 src/scenegraph/shaders/sdf.glsl                  | 42 +++---------------------
 src/scenegraph/shadowedbordertexturematerial.cpp |  9 +++--
 src/scenegraph/shadowedtexturematerial.cpp       |  9 +++--
 5 files changed, 30 insertions(+), 51 deletions(-)

diff --git a/src/controls/Card.qml b/src/controls/Card.qml
index 3369241..056123c 100644
--- a/src/controls/Card.qml
+++ b/src/controls/Card.qml
@@ -67,16 +67,21 @@ Kirigami.AbstractCard {
 
     header: BannerImage {
         id: bannerImage
-        anchors.leftMargin: -root.leftPadding
-        anchors.topMargin: -root.topPadding
-        anchors.rightMargin: root.headerOrientation == Qt.Vertical ? -root.rightPadding : 0
-        anchors.bottomMargin: root.headerOrientation == Qt.Horizontal ? -root.bottomPadding : 0
+        anchors.leftMargin: -root.leftPadding + root.background.border.width
+        anchors.topMargin: -root.topPadding + root.background.border.width
+        anchors.rightMargin: root.headerOrientation == Qt.Vertical ? -root.rightPadding + root.background.border.width : 0
+        anchors.bottomMargin: root.headerOrientation == Qt.Horizontal ? -root.bottomPadding + root.background.border.width : 0
         //height: Layout.preferredHeight
         implicitWidth: root.headerOrientation == Qt.Horizontal ? sourceSize.width : Layout.preferredWidth
 
-        corners.topLeftRadius: root.background.radius
-        corners.topRightRadius: root.headerOrientation == Qt.Horizontal ? 0 : root.background.radius
-        corners.bottomLeftRadius: root.headerOrientation == Qt.Horizontal ? root.background.radius : 0
+        readonly property real widthWithBorder: width + root.background.border.width * 2
+        readonly property real heightWithBorder: height + root.background.border.width * 2
+        readonly property real radiusFromBackground: root.background.radius - root.background.border.width
+
+        corners.topLeftRadius: radiusFromBackground
+        corners.topRightRadius: (root.headerOrientation == Qt.Horizontal && widthWithBorder < root.width) ? 0 : radiusFromBackground
+        corners.bottomLeftRadius: (root.headerOrientation != Qt.Horizontal && heightWithBorder < root.height) ? 0 : radiusFromBackground
+        corners.bottomRightRadius: heightWithBorder < root.height ? 0 : radiusFromBackground
     }
 
     onHeaderChanged: {
diff --git a/src/controls/private/BannerImage.qml b/src/controls/private/BannerImage.qml
index ec4a12d..9e4fbad 100644
--- a/src/controls/private/BannerImage.qml
+++ b/src/controls/private/BannerImage.qml
@@ -92,6 +92,8 @@ Kirigami.ShadowedImage {
 
         corners.topLeftRadius: root.titleAlignment & Qt.AlignTop ? root.corners.topLeftRadius : 0
         corners.topRightRadius: root.titleAlignment & Qt.AlignTop ? root.corners.topRightRadius : 0
+        corners.bottomLeftRadius: root.titleAlignment & Qt.AlignBottom ? root.corners.bottomLeftRadius : 0
+        corners.bottomRightRadius: root.titleAlignment & Qt.AlignBottom ? root.corners.bottomRightRadius : 0
     }
 
     RowLayout {
diff --git a/src/scenegraph/shaders/sdf.glsl b/src/scenegraph/shaders/sdf.glsl
index e47627f..e809a3e 100644
--- a/src/scenegraph/shaders/sdf.glsl
+++ b/src/scenegraph/shaders/sdf.glsl
@@ -67,40 +67,6 @@ lowp float sdf_triangle(in lowp vec2 point, in lowp vec2 p0, in lowp vec2 p1, in
     return -sqrt(d.x)*sign(d.y);
 }
 
-// Distance field for an arbitrary polygon.
-//
-// \param point A point on the distance field.
-// \param vertices An array of points that make up the polygon.
-// \param count The amount of points to use for the polygon.
-//
-// \note points should be an array of vec2 of size SDF_POLYGON_MAX_POINT_COUNT.
-//       Use count to indicate how many items of that array should be used.
-//
-// \return The signed distance from point to triangle. If negative, point is
-//         inside the triangle.
-
-// Strictly speaking, GLES 2.0 doesn't support function array arguments (apparently), so our validation fails here.
-// But at least Mesa GLES 2.0 accepts it, so skip validation here instead.
-#if !defined(GL_ES) || !defined(VALIDATING)
-lowp float sdf_polygon(in lowp vec2 point, in lowp vec2[SDF_POLYGON_MAX_POINT_COUNT] vertices, in lowp int count)
-{
-    lowp float d = dot(point - vertices[0], point - vertices[0]);
-    lowp float s = 1.0;
-    for (int i = 0, j = count - 1; i < count && i < SDF_POLYGON_MAX_POINT_COUNT; j = i, i++)
-    {
-        lowp vec2 e = vertices[j] - vertices[i];
-        lowp vec2 w = point - vertices[i];
-        lowp float h = clamp( dot(w, e) / dot(e, e), 0.0, 1.0 );
-        lowp vec2 b = w - e * h;
-        d = min(d, dot(b, b));
-
-        bvec3 c = bvec3(point.y >= vertices[i].y, point.y < vertices[j].y, e.x * w.y > e.y * w.x);
-        if(all(c) || all(not(c))) s *= -1.0;
-    }
-    return s * sqrt(d);
-}
-#endif
-
 // Distance field for a rectangle.
 //
 // \param point A point on the distance field.
@@ -230,7 +196,7 @@ const lowp float sdf_null = 99999.0;
 // A constant for a default level of smoothing when rendering an sdf.
 //
 // This
-const lowp float sdf_default_smoothing = 0.005;
+const lowp float sdf_default_smoothing = 0.625;
 
 // Render an sdf shape.
 //
@@ -245,7 +211,7 @@ const lowp float sdf_default_smoothing = 0.005;
 lowp vec4 sdf_render(in lowp float sdf, in lowp vec4 sourceColor, in lowp vec4 sdfColor)
 {
     lowp float g = fwidth(sdf);
-    return mix(sourceColor, sdfColor, 1.0 - smoothstep(sdf_default_smoothing - g, sdf_default_smoothing + g, sdf));
+    return mix(sourceColor, sdfColor, 1.0 - smoothstep(-sdf_default_smoothing * g, sdf_default_smoothing * g, sdf));
 }
 
 // Render an sdf shape.
@@ -258,7 +224,7 @@ lowp vec4 sdf_render(in lowp float sdf, in lowp vec4 sourceColor, in lowp vec4 s
 lowp vec4 sdf_render(in lowp float sdf, in lowp vec4 sourceColor, in lowp vec4 sdfColor, in lowp float smoothing)
 {
     lowp float g = fwidth(sdf);
-    return mix(sourceColor, sdfColor, 1.0 - smoothstep(smoothing - g, smoothing + g, sdf));
+    return mix(sourceColor, sdfColor, 1.0 - smoothstep(-smoothing * g, smoothing * g, sdf));
 }
 
 // Render an sdf shape alpha-blended onto an existing color.
@@ -272,5 +238,5 @@ lowp vec4 sdf_render(in lowp float sdf, in lowp vec4 sourceColor, in lowp vec4 s
 lowp vec4 sdf_render(in lowp float sdf, in lowp vec4 sourceColor, in lowp vec4 sdfColor, in lowp float alpha, in lowp float smoothing)
 {
     lowp float g = fwidth(sdf);
-    return mix(sourceColor, sdfColor, alpha * (1.0 - smoothstep(smoothing - g, smoothing + g, sdf)));
+    return mix(sourceColor, sdfColor, alpha * (1.0 - smoothstep(-smoothing * g, smoothing * g, sdf)));
 }
diff --git a/src/scenegraph/shadowedbordertexturematerial.cpp b/src/scenegraph/shadowedbordertexturematerial.cpp
index 19dfbef..843797f 100644
--- a/src/scenegraph/shadowedbordertexturematerial.cpp
+++ b/src/scenegraph/shadowedbordertexturematerial.cpp
@@ -31,9 +31,12 @@ int ShadowedBorderTextureMaterial::compare(const QSGMaterial *other) const
     auto material = static_cast<const ShadowedBorderTextureMaterial *>(other);
 
     auto result = ShadowedBorderRectangleMaterial::compare(other);
-    if (result == 0
-        && material->textureSource == textureSource) {
-        return 0;
+    if (result == 0) {
+        if (material->textureSource == textureSource) {
+            return 0;
+        } else {
+            return (material->textureSource < textureSource) ? 1 : -1;
+        }
     }
 
     return result;
diff --git a/src/scenegraph/shadowedtexturematerial.cpp b/src/scenegraph/shadowedtexturematerial.cpp
index 71dee81..ec4f4e6 100644
--- a/src/scenegraph/shadowedtexturematerial.cpp
+++ b/src/scenegraph/shadowedtexturematerial.cpp
@@ -31,9 +31,12 @@ int ShadowedTextureMaterial::compare(const QSGMaterial *other) const
     auto material = static_cast<const ShadowedTextureMaterial *>(other);
 
     auto result = ShadowedRectangleMaterial::compare(other);
-    if (result == 0
-        && material->textureSource == textureSource) {
-        return 0;
+    if (result == 0) {
+        if (material->textureSource == textureSource) {
+            return 0;
+        } else {
+            return (material->textureSource < textureSource) ? 1 : -1;
+        }
     }
 
     return result;
-- 
cgit v1.1

