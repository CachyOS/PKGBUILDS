From e770b0ddd2af7fc861be45044476b4fa062ccc1d Mon Sep 17 00:00:00 2001
From: Arjen Hiemstra <ahiemstra@heimr.nl>
Date: Tue, 21 Apr 2020 11:40:13 +0200
Subject: Use ShadowedRectangle for Card backgrounds

Summary:
This switches cards to use ShadowedRectangle for their background. It also refreshes their
design a bit, based on feedback from the VDG.

Still WIP because of potential design issues and I'm not entirely happy with the code for
the actual cards. Ideally I'd also move a bunch of this stuff to C++ but that'd involve a
reimplementing a bunch of Control behaviour.

BUG: 415526

Test Plan:
New cards, normal colour scheme:

{F8221005}

Breeze Dark:

{F8221010}

Reviewers: #kirigami, #vdg, cblack, mart

Reviewed By: #kirigami, #vdg, cblack, mart

Subscribers: mart, ngraham, nicolasfella, cblack, plasma-devel

Tags: #kirigami

Differential Revision: https://phabricator.kde.org/D28625
---
 src/colorutils.cpp                             | 21 +++++-
 src/colorutils.h                               | 18 +++++
 src/controls/AbstractCard.qml                  | 33 ++++-----
 src/controls/Card.qml                          |  6 +-
 src/controls/ShadowedImage.qml                 | 14 ++--
 src/controls/private/BannerImage.qml           | 36 +++++-----
 src/controls/private/DefaultCardBackground.qml | 92 +++-----------------------
 src/scenegraph/shaders/sdf.glsl                |  2 +-
 src/scenegraph/shadowedtexturenode.cpp         |  2 +-
 src/shadowedtexture.cpp                        | 45 ++++---------
 10 files changed, 111 insertions(+), 158 deletions(-)

diff --git a/src/colorutils.cpp b/src/colorutils.cpp
index cab1ced..beaab24 100644
--- a/src/colorutils.cpp
+++ b/src/colorutils.cpp
@@ -190,4 +190,23 @@ QColor ColorUtils::scaleColor(QColor color, QJSValue adjustments)
     }
 
     return copy;
-}
\ No newline at end of file
+}
+
+QColor ColorUtils::tintWithAlpha(const QColor &targetColor, const QColor &tintColor, double alpha)
+{
+    qreal tintAlpha = tintColor.alphaF() * alpha;
+    qreal inverseAlpha = 1.0 - tintAlpha;
+
+    if (qFuzzyCompare(tintAlpha, 1.0)) {
+        return tintColor;
+    } else if (qFuzzyIsNull(tintAlpha)) {
+        return targetColor;
+    }
+
+    return QColor::fromRgbF(
+        tintColor.redF() * tintAlpha + targetColor.redF() * inverseAlpha,
+        tintColor.greenF() * tintAlpha + targetColor.greenF() * inverseAlpha,
+        tintColor.blueF() * tintAlpha + targetColor.blueF() * inverseAlpha,
+        tintAlpha + inverseAlpha * targetColor.alphaF()
+    );
+}
diff --git a/src/colorutils.h b/src/colorutils.h
index ae94791..e1d8446 100644
--- a/src/colorutils.h
+++ b/src/colorutils.h
@@ -159,4 +159,22 @@ public:
      * @since org.kde.kirigami 2.12
      */
     Q_INVOKABLE QColor scaleColor(QColor color, QJSValue adjustments);
+
+    /**
+     * Tint a color using a separate alpha value.
+     *
+     * This does the same as Qt.tint() except that rather than using the tint
+     * color's alpha value, it uses a separate value that gets multiplied with
+     * the tint color's alpha. This avoids needing to create a new color just to
+     * adjust an alpha value.
+     *
+     * \param targetColor The color to tint.
+     * \param tintColor The color to tint with.
+     * \param alpha The amount of tinting to apply.
+     *
+     * \return The tinted color.
+     *
+     * \sa Qt.tint()
+     */
+    Q_INVOKABLE QColor tintWithAlpha(const QColor &targetColor, const QColor &tintColor, double alpha);
 };
diff --git a/src/controls/AbstractCard.qml b/src/controls/AbstractCard.qml
index 7f35422..c5dbde8 100644
--- a/src/controls/AbstractCard.qml
+++ b/src/controls/AbstractCard.qml
@@ -5,8 +5,7 @@
  */
 
 import QtQuick 2.6
-import QtGraphicalEffects 1.0
-import org.kde.kirigami 2.4 as Kirigami
+import org.kde.kirigami 2.12
 import "templates" as T
 import "private"
 
@@ -27,21 +26,25 @@ T.AbstractCard {
     id: root
 
     background: DefaultCardBackground {
-        Rectangle {
-            anchors.fill: parent
-            color: Kirigami.Theme.highlightColor
-            opacity: {
-                if (root.showClickFeedback || highlighted) {
-                    return (root.highlighted || root.down) ? 0.3 : (root.hovered ? 0.1 : 0);
-                } else {
-                    return 0;
+        id: bg
+
+        readonly property color pressedColor: ColorUtils.tintWithAlpha(Theme.backgroundColor, Theme.highlightColor, 0.3)
+        readonly property color hoverColor: ColorUtils.tintWithAlpha(Theme.backgroundColor, Theme.highlightColor, 0.1)
+
+        color: {
+            if (root.showClickFeedback || highlighted) {
+                if (root.highlighted || root.down) {
+                    return bg.pressedColor
+                } else if (root.hovered) {
+                    return bg.hoverColor
                 }
             }
-            Behavior on opacity {
-                OpacityAnimator {
-                    duration: Kirigami.Units.longDuration
-                    easing.type: Easing.InOutQuad
-                }
+            return Theme.backgroundColor
+        }
+        Behavior on color {
+            ColorAnimation {
+                duration: Units.longDuration
+                easing.type: Easing.InOutQuad
             }
         }
     }
diff --git a/src/controls/Card.qml b/src/controls/Card.qml
index d511269..3369241 100644
--- a/src/controls/Card.qml
+++ b/src/controls/Card.qml
@@ -7,7 +7,7 @@
 import QtQuick 2.6
 import QtQuick.Layouts 1.2
 import QtQuick.Controls 2.0 as Controls
-import org.kde.kirigami 2.5 as Kirigami
+import org.kde.kirigami 2.12 as Kirigami
 import "private"
 
 /**
@@ -73,6 +73,10 @@ Kirigami.AbstractCard {
         anchors.bottomMargin: root.headerOrientation == Qt.Horizontal ? -root.bottomPadding : 0
         //height: Layout.preferredHeight
         implicitWidth: root.headerOrientation == Qt.Horizontal ? sourceSize.width : Layout.preferredWidth
+
+        corners.topLeftRadius: root.background.radius
+        corners.topRightRadius: root.headerOrientation == Qt.Horizontal ? 0 : root.background.radius
+        corners.bottomLeftRadius: root.headerOrientation == Qt.Horizontal ? root.background.radius : 0
     }
 
     onHeaderChanged: {
diff --git a/src/controls/ShadowedImage.qml b/src/controls/ShadowedImage.qml
index 6a69216..dbcf6d1 100644
--- a/src/controls/ShadowedImage.qml
+++ b/src/controls/ShadowedImage.qml
@@ -13,15 +13,21 @@ Item {
     property alias shadow: shadowRectangle.shadow
     property alias border: shadowRectangle.border
     property alias corners: shadowRectangle.corners
+
     property alias source: image.source
+    property alias asynchronous: image.asynchronous
+    property alias fillMode: image.fillMode
+    property alias sourceSize: image.sourceSize
+
+    Image {
+        id: image
+        visible: false
+    }
 
     ShadowedTexture {
         id: shadowRectangle
         anchors.fill: parent
 
-        source: Image {
-            id: image
-            visible: false
-        }
+        source: image.status == Image.Ready ? image : null
     }
 }
diff --git a/src/controls/private/BannerImage.qml b/src/controls/private/BannerImage.qml
index 877afae..ec4a12d 100644
--- a/src/controls/private/BannerImage.qml
+++ b/src/controls/private/BannerImage.qml
@@ -7,14 +7,14 @@
 import QtQuick 2.6
 import QtQuick.Layouts 1.2
 import QtGraphicalEffects 1.0
-import org.kde.kirigami 2.4 as Kirigami
+import org.kde.kirigami 2.12 as Kirigami
 
 /**
  * This Component is used as the header of GlobalDrawer and as the header
  * of Card, It can be accessed there as a grouped property but can never
  * be instantiated directly
  */
-Image {
+Kirigami.ShadowedImage {
     id: root
 
     /*
@@ -70,34 +70,28 @@ Image {
     fillMode: Image.PreserveAspectCrop
     asynchronous: true
 
+    color: "transparent"
+
     Component.onCompleted: {
         titleLayout.completed = true;
     }
 
-    LinearGradient {
+    Kirigami.ShadowedRectangle {
         anchors {
             left: parent.left
             right: parent.right
-            top: root.status !=
-Image.Ready || (root.titleAlignment & Qt.AlignTop) ? parent.top : undefined
-            bottom: root.status !=
-Image.Ready || (root.titleAlignment & Qt.AlignBottom) ? parent.bottom : undefined
+            top: (root.titleAlignment & Qt.AlignTop) ? parent.top : undefined
+            bottom: (root.titleAlignment & Qt.AlignBottom) ? parent.bottom : undefined
         }
+        height: Math.min(parent.height, titleLayout.height * 1.5)
+
+        opacity: 0.5
+        color: "black"
+
         visible: root.source != "" && root.title != "" && ((root.titleAlignment & Qt.AlignTop) || (root.titleAlignment & Qt.AlignBottom))
-        height: Math.min(parent.height, titleLayout.height * 2)
-        start: Qt.point(0, 0)
-        end: Qt.point(0, height)
-        gradient: Gradient {
-            GradientStop {
-                position: (root.titleAlignment & Qt.AlignTop) ? 0.0 : 1.0
-                color: Qt.rgba(0, 0, 0, 0.8)
-            }
-            GradientStop {
-                position: (root.titleAlignment & Qt.AlignTop) ? 1.0 : 0.0
-                color: Qt.rgba(0, 0, 0, root.status ==
-Image.Ready ? 0 : 0.3)
-            }
-        }
+
+        corners.topLeftRadius: root.titleAlignment & Qt.AlignTop ? root.corners.topLeftRadius : 0
+        corners.topRightRadius: root.titleAlignment & Qt.AlignTop ? root.corners.topRightRadius : 0
     }
 
     RowLayout {
diff --git a/src/controls/private/DefaultCardBackground.qml b/src/controls/private/DefaultCardBackground.qml
index 70cba43..b29e0e6 100644
--- a/src/controls/private/DefaultCardBackground.qml
+++ b/src/controls/private/DefaultCardBackground.qml
@@ -5,89 +5,19 @@
  */
 
 import QtQuick 2.6
-import org.kde.kirigami 2.11 as Kirigami
+import org.kde.kirigami 2.12 as Kirigami
 
-Rectangle {
+Kirigami.ShadowedRectangle {
     color: Kirigami.Theme.backgroundColor
 
-    CornerShadow {
-        id: topLeft
-        corner: Qt.BottomRightCorner
-        z: -1
-        anchors {
-            right: parent.left
-            bottom: parent.top
-            margins: margin
-            bottomMargin: margin - 1
-        }
-    }
-    CornerShadow {
-        id: topRight
-        corner: Qt.BottomLeftCorner
-        z: -1
-        anchors {
-            left: parent.right
-            bottom: parent.top
-            margins: margin
-            bottomMargin: margin - 1
-        }
-    }
-    CornerShadow {
-        id: bottomLeft
-        corner: Qt.TopRightCorner
-        z: -1
-        anchors {
-            right: parent.left
-            top: parent.bottom
-            margins: margin
-        }
-    }
-    CornerShadow {
-        id: bottomRight
-        corner: Qt.TopLeftCorner
-        z: -1
-        anchors {
-            left: parent.right
-            top: parent.bottom
-            margins: margin
-        }
-    }
-    EdgeShadow {
-        edge: Qt.BottomEdge
-        z: -1
-        anchors {
-            left: bottomLeft.right
-            right: bottomRight.left
-            bottom: parent.top
-            bottomMargin: - 1
-        }
-    }
-    EdgeShadow {
-        edge: Qt.TopEdge
-        z: -1
-        anchors {
-            left: topLeft.right
-            right: topRight.left
-            top: parent.bottom
-        }
-    }
-    EdgeShadow {
-        edge: Qt.LeftEdge
-        z: -1
-        anchors {
-            top: topRight.bottom
-            bottom: bottomRight.top
-            left: parent.right
-        }
-    }
-    EdgeShadow {
-        edge: Qt.RightEdge
-        z: -1
-        anchors {
-            top: topLeft.bottom
-            bottom: bottomLeft.top
-            right: parent.left
-        }
-    }
+    radius: Kirigami.Units.smallSpacing
+
+    shadow.size: Kirigami.Units.largeSpacing
+    shadow.color: Qt.rgba(0.0, 0.0, 0.0, 0.15)
+    shadow.yOffset: Kirigami.Units.devicePixelRatio * 2
+
+    border.width: Kirigami.Units.devicePixelRatio
+    border.color: Qt.tint(Kirigami.Theme.textColor,
+                          Qt.rgba(color.r, color.g, color.b, 0.6))
 }
 
diff --git a/src/scenegraph/shaders/sdf.glsl b/src/scenegraph/shaders/sdf.glsl
index e495fe9..e47627f 100644
--- a/src/scenegraph/shaders/sdf.glsl
+++ b/src/scenegraph/shaders/sdf.glsl
@@ -230,7 +230,7 @@ const lowp float sdf_null = 99999.0;
 // A constant for a default level of smoothing when rendering an sdf.
 //
 // This
-const lowp float sdf_default_smoothing = 0.001;
+const lowp float sdf_default_smoothing = 0.005;
 
 // Render an sdf shape.
 //
diff --git a/src/scenegraph/shadowedtexturenode.cpp b/src/scenegraph/shadowedtexturenode.cpp
index 53bc59e..446cce4 100644
--- a/src/scenegraph/shadowedtexturenode.cpp
+++ b/src/scenegraph/shadowedtexturenode.cpp
@@ -51,7 +51,7 @@ void ShadowedTextureNode::setTextureSource(QSGTextureProvider *source)
 
 void ShadowedTextureNode::preprocess()
 {
-    if (m_textureSource && m_material) {
+    if (m_textureSource && m_material && m_textureSource->texture()) {
         if (m_material->type() == borderlessMaterialType()) {
             preprocessTexture<ShadowedTextureMaterial>(m_material, m_textureSource);
         } else {
diff --git a/src/shadowedtexture.cpp b/src/shadowedtexture.cpp
index 9671532..794ca35 100644
--- a/src/shadowedtexture.cpp
+++ b/src/shadowedtexture.cpp
@@ -33,7 +33,8 @@ void ShadowedTexture::setSource(QQuickItem *newSource)
     }
 
     m_source = newSource;
-    if (!m_source->parentItem()) {
+    m_sourceChanged = true;
+    if (m_source && !m_source->parentItem()) {
         m_source->setParentItem(this);
     }
 
@@ -45,11 +46,17 @@ QSGNode *ShadowedTexture::updatePaintNode(QSGNode *node, QQuickItem::UpdatePaint
 {
     Q_UNUSED(data);
 
-    if (!node) {
-        node = new ShadowedTextureNode{};
+    if (!node || m_sourceChanged) {
+        m_sourceChanged = false;
+        delete node;
+        if (m_source) {
+            node = new ShadowedTextureNode{};
+        } else {
+            node = new ShadowedRectangleNode{};
+        }
     }
 
-    auto shadowNode = static_cast<ShadowedTextureNode*>(node);
+    auto shadowNode = static_cast<ShadowedRectangleNode*>(node);
     shadowNode->setBorderEnabled(border()->isEnabled());
     shadowNode->setRect(boundingRect());
     shadowNode->setSize(shadow()->size());
@@ -61,37 +68,9 @@ QSGNode *ShadowedTexture::updatePaintNode(QSGNode *node, QQuickItem::UpdatePaint
     shadowNode->setBorderColor(border()->color());
 
     if (m_source) {
-        shadowNode->setTextureSource(m_source->textureProvider());
+        static_cast<ShadowedTextureNode*>(node)->setTextureSource(m_source->textureProvider());
     }
 
     shadowNode->updateGeometry();
     return shadowNode;
 }
-
-// void ShadowedTexture::checkSoftwareItem()
-// {
-//     if (!m_softwareItem && window() && window()->rendererInterface()->graphicsApi() == QSGRendererInterface::Software) {
-//         m_softwareItem = new PaintedRectangleItem{this};
-//
-//         auto updateItem = [this]() {
-//             auto borderWidth = m_border->width();
-//             auto rect = boundingRect().adjusted(-borderWidth / 2, -borderWidth / 2, borderWidth / 2, borderWidth / 2);
-//             m_softwareItem->setX(-borderWidth / 2);
-//             m_softwareItem->setY(-borderWidth / 2);
-//             m_softwareItem->setSize(rect.size());
-//             m_softwareItem->setColor(m_color);
-//             m_softwareItem->setRadius(m_radius);
-//             m_softwareItem->setBorderWidth(borderWidth);
-//             m_softwareItem->setBorderColor(m_border->color());
-//         };
-//
-//         updateItem();
-//
-//         connect(this, &ShadowedTexture::widthChanged, m_softwareItem, updateItem);
-//         connect(this, &ShadowedTexture::heightChanged, m_softwareItem, updateItem);
-//         connect(this, &ShadowedRectangle::colorChanged, m_softwareItem, updateItem);
-//         connect(this, &ShadowedRectangle::radiusChanged, m_softwareItem, updateItem);
-//         connect(m_border.get(), &BorderGroup::changed, m_softwareItem, updateItem);
-//         setFlag(QQuickItem::ItemHasContents, false);
-//     }
-// }
-- 
cgit v1.1

